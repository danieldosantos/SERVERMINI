# Skript utilitário da classe Monge
options:
  prefix: &6[Monge]&r
  posture-duration: 9
  combo-timeout: 6

function monk_is_class(p: player) :: boolean:
  if {_p} has permission "class_monk":
    return true
  return false

function monk_refresh_hud(p: player):
  set {_name} to name of {_p}
  execute console command "placeholderapi refresh %{_name}% monk_stamina"
  execute console command "placeholderapi refresh %{_name}% monk_ki"
  execute console command "placeholderapi refresh %{_name}% monk_combo"
  execute console command "placeholderapi refresh %{_name}% monk_posture"
  execute console command "placeholderapi refresh %{_name}% monk_cooldowns"

function monk_cast_postura(p: player):
  set {_name} to name of {_p}
  execute console command "skillapi cast monk_focus_stance %{_name}%"

command /golpe_ki:
  permission: class_monk
  trigger:
    execute console command "skillapi cast monk_flurry_of_blows %player%"

command /passo_vento:
  permission: class_monk
  trigger:
    execute console command "skillapi cast monk_step_of_the_wind %player%"

command /defletir:
  permission: class_monk
  trigger:
    execute console command "skillapi cast monk_deflect_projectiles %player%"

command /combo:
  permission: class_monk
  trigger:
    set {_combo} to {monk.combo.%player%}
    if {_combo} is not set:
      set {_combo} to 0
    send "{@prefix} &7Stacks de combo: &e%{_combo}%" to player

command /estilo_openhand:
  permission: class_monk
  trigger:
    execute console command "lp user %player% parent remove class_monk.shadow"
    execute console command "lp user %player% parent remove class_monk.elements"
    execute console command "lp user %player% parent add class_monk.openhand"
    send "{@prefix} &aSubclasse trocada para Mão Aberta." to player

command /estilo_shadow:
  permission: class_monk
  trigger:
    execute console command "lp user %player% parent remove class_monk.openhand"
    execute console command "lp user %player% parent remove class_monk.elements"
    execute console command "lp user %player% parent add class_monk.shadow"
    send "{@prefix} &8Subclasse trocada para Sombra." to player

command /estilo_elements:
  permission: class_monk
  trigger:
    execute console command "lp user %player% parent remove class_monk.openhand"
    execute console command "lp user %player% parent remove class_monk.shadow"
    execute console command "lp user %player% parent add class_monk.elements"
    send "{@prefix} &bSubclasse trocada para Quatro Elementos." to player

command /kit_monge:
  permission: class_monk
  trigger:
    clear player's inventory
    execute console command "mm items give %player% MonkPrayerBeads 1"
    execute console command "mm items give %player% MonkWindWraps 1"
    execute console command "mm items give %player% MonkFocusBand 1"
    if player has permission "class_monk.openhand":
      execute console command "mm items give %player% OpenHandWraps 1"
      execute console command "mm items give %player% SereneSash 1"
      execute console command "mm items give %player% PalmCharm 1"
    if player has permission "class_monk.shadow":
      execute console command "mm items give %player% ShadowCowl 1"
      execute console command "mm items give %player% SmokePellet 3"
      execute console command "mm items give %player% NightSilkBelt 1"
    if player has permission "class_monk.elements":
      execute console command "mm items give %player% ElementScrollFire 1"
      execute console command "mm items give %player% ElementScrollFrost 1"
      execute console command "mm items give %player% ElementScrollGale 1"
      execute console command "mm items give %player% ElementStoneBand 1"
      execute console command "mm items give %player% ElementStormFocus 1"
    execute console command "cmi heal %player%"
    set {monk.combo.%player%} to 0
    delete {monk.posture.%player%::*}
    monk_refresh_hud(player)
    send "{@prefix} &7Kit de testes aplicado."

on damage:
  if attacker is a player:
    if monk_is_class(attacker) is true:
      set {monk.incombat.%attacker%} to now + 8 seconds
      add 1 to {monk.combo.%attacker%}
      if {monk.combo.%attacker%} > 6:
        set {monk.combo.%attacker%} to 6
      set {monk.last_hit.%attacker%} to now
      if {monk.flurry.%attacker%::expires} is set:
        if {monk.flurry.%attacker%::expires} > now:
          if {monk.flurry.%attacker%::remaining} > 0:
            damage victim by event-damage * {monk.flurry.%attacker%::mult}
            subtract 1 from {monk.flurry.%attacker%::remaining}
            if {monk.flurry.%attacker%::remaining} <= 0:
              delete {monk.flurry.%attacker%::*}
      if {monk.shadowbind.%attacker%::target} is set:
        if {monk.shadowbind.%attacker%::expires} > now:
          if victim = {monk.shadowbind.%attacker%::target}:
            set {_stack} to {monk.shadowbind.%attacker%::stacks}
            if {_stack} is not set:
              set {_stack} to 0
            set {_bonus} to event-damage * {monk.shadowbind.%attacker%::amount} * ({_stack} + 1)
            damage victim by {_bonus}
            if {_stack} < 1:
              add 1 to {_stack}
            set {monk.shadowbind.%attacker%::stacks} to {_stack}
        else:
          delete {monk.shadowbind.%attacker%::*}
      monk_refresh_hud(attacker)
  if victim is a player:
    if monk_is_class(victim) is true:
      set {monk.incombat.%victim%} to now + 8 seconds
      if {monk.deflect.%victim%::expires} is set:
        if {monk.deflect.%victim%::expires} > now:
          if projectile is set:
            set event-damage to event-damage * (1 - {monk.deflect.%victim%::reduction})
            if {monk.deflect.%victim%::reflected} is false:
              if shooter of projectile is a living entity:
                damage shooter of projectile by event-damage * {monk.deflect.%victim%::reflect}
              set {monk.deflect.%victim%::reflected} to true
      if {monk.posture.%victim%::active} is true:
        set event-damage to event-damage * 0.9
      monk_refresh_hud(victim)

on damage:
  if victim is a player:
    if monk_is_class(victim) is true:
      if event is cancelled or event-damage <= 0:
        if {monk.discipline.%victim%::amount} is set:
          if {monk.discipline.%victim%::next} <= now:
            set {_name} to name of victim
            execute console command "skillapi mana add %{_name}% %{monk.discipline.%victim%::amount}%"
            set {monk.discipline.%victim%::next} to now + {monk.discipline.%victim%::cooldown} seconds
            send action bar "&eDisciplina +%{monk.discipline.%victim%::amount}% Estamina" to victim

on damage of player:
  if monk_is_class(victim) is true:
    if damage cause is fall:
      if {monk.stepwind.%victim%} is set and {monk.stepwind.%victim%} > now:
        set event-damage to event-damage * 0.3
      if {monk.softfall.%victim%} is set and {monk.softfall.%victim%} > now:
        set event-damage to event-damage * (1 - {monk.softfall.%victim%::reduction})

every 1 second:
  loop all players:
    if monk_is_class(loop-player) is true:
      if {monk.incombat.%loop-player%} is set:
        if {monk.incombat.%loop-player%} <= now:
          delete {monk.incombat.%loop-player%}
      if {monk.last_hit.%loop-player%} is set:
        if difference between now and {monk.last_hit.%loop-player%} > {@combo-timeout} seconds:
          set {monk.combo.%loop-player%} to 0
      if {monk.posture.%loop-player%::active} is true:
        if {monk.posture.%loop-player%::expires} <= now:
          monk_disable_posture(loop-player)
      if {monk.shadowbind.%loop-player%::expires} is set:
        if {monk.shadowbind.%loop-player%::expires} <= now:
          delete {monk.shadowbind.%loop-player%::*}
      monk_refresh_hud(loop-player)

function monk_flurry_window(p: player, t: entity, hits: number, duration: number, mult: number):
  set {monk.flurry.%{_p}%::remaining} to hits parsed as number
  set {monk.flurry.%{_p}%::expires} to now + duration parsed as number seconds
  set {monk.flurry.%{_p}%::mult} to mult parsed as number
  send action bar "&eRajada de Golpes ativa" to {_p}
  monk_refresh_hud({_p})

function monk_step_wind(p: player, seconds: number):
  set {monk.stepwind.%{_p}%} to now + seconds parsed as number seconds

function monk_deflect_window(p: player, seconds: number, reduction: number, reflect: number):
  set {monk.deflect.%{_p}%::expires} to now + seconds parsed as number seconds
  set {monk.deflect.%{_p}%::reduction} to reduction parsed as number
  set {monk.deflect.%{_p}%::reflect} to reflect parsed as number
  set {monk.deflect.%{_p}%::reflected} to false
  send action bar "&bDefletindo projéteis" to {_p}

function monk_focus_toggle(p: player):
  if {monk.posture.%{_p}%::active} is true:
    monk_disable_posture({_p})
  else:
    set {monk.posture.%{_p}%::active} to true
    set {monk.posture.%{_p}%::expires} to now + {@posture-duration} seconds
    monk_refresh_hud({_p})
    send action bar "&6Postura de Foco ativada" to {_p}

function monk_disable_posture(p: player):
  delete {monk.posture.%{_p}%::active}
  delete {monk.posture.%{_p}%::expires}
  send action bar "&6Postura de Foco encerrada" to {_p}
  monk_refresh_hud({_p})

function monk_unarmored_update(p: player):
  set {_dex} to placeholderapi "%races_stat_dexterity%" with {_p}
  set {_wis} to placeholderapi "%races_stat_wisdom%" with {_p}
  set {_base} to ((parsed number from {_dex}) + (parsed number from {_wis})) * 0.0025
  if {_base} > 0.15:
    set {_base} to 0.15
  set {monk.unarmored.%{_p}%} to {_base}

function monk_register_discipline(p: player, stamina: number, cooldown: number):
  set {monk.discipline.%{_p}%::amount} to stamina parsed as number
  set {monk.discipline.%{_p}%::cooldown} to cooldown parsed as number
  set {monk.discipline.%{_p}%::next} to now

function monk_apply_tropeco(t: entity, seconds: number):
  apply slowness 2 to {_t} for seconds parsed as number seconds

function monk_interrupt(t: entity):
  if {_t} is a player:
    execute console command "skillapi cancel %{_t}%"

function monk_push_resistance(t: entity):
  if {_t} is a player:
    execute console command "raceseffects apply_resistance_exhaust %{_t}%"

function monk_soft_fall(p: player, seconds: number, reduction: number):
  set {monk.softfall.%{_p}%} to now + seconds parsed as number seconds
  set {monk.softfall.%{_p}%::reduction} to reduction parsed as number

function monk_heal_cap(target: entity, cap: number):
  if {_target} is a player:
    execute console command "placeholderapi refresh %{_target}% monk_heal"

function monk_resounding_palm(p: player, radius: number, duration: number, damage: number, root: number):
  set {_end} to now + duration parsed as number seconds
  while {_end} > now:
    loop all entities in radius radius parsed as number around {_p}:
      if loop-entity is not {_p}:
        damage loop-entity by damage parsed as number
        apply slowness 4 to loop-entity for root parsed as number seconds
    wait 1 second

function monk_shadow_step(p: player, distance: number):
  set {_loc} to target block of {_p} within distance parsed as number
  if {_loc} is not set:
    send "&cNecessário mirar em penumbra." to {_p}
    stop
  set {_light} to light level of {_loc}
  if {_light} > 7:
    send "&cPasso das Sombras falha: luz ambiente muito alta." to {_p}
    stop
  teleport {_p} to {_loc}
  show smoke for all players at location of {_p} with radius 1.5

function monk_smoke_pellet(p: player, radius: number, seconds: number, blind: number):
  repeat seconds parsed as number times:
    loop all players in radius radius parsed as number around {_p}:
      if loop-player != {_p}:
        apply blindness 1 to loop-player for blind parsed as number seconds
    show big smoke for all players at location of {_p} with radius radius parsed as number
    wait 1 second

function monk_shadow_blind(t: entity, seconds: number):
  apply blindness 1 to {_t} for seconds parsed as number seconds

function monk_silent_veil(p: player, seconds: number, dodge: number):
  set {monk.silent.%{_p}%} to now + seconds parsed as number seconds
  send action bar "&8Véu Silencioso ativo" to {_p}

function monk_shadow_bind(c: player, t: entity, seconds: number, amount: number):
  if {_t} is set:
    set {monk.shadowbind.%{_c}%::target} to {_t}
    set {monk.shadowbind.%{_c}%::expires} to now + seconds parsed as number seconds
    set {monk.shadowbind.%{_c}%::amount} to amount parsed as number
    set {monk.shadowbind.%{_c}%::stacks} to 0

function monk_flame_burn(p: player, t: entity, seconds: number, tick: number):
  repeat seconds parsed as number times:
    damage {_t} by tick parsed as number
    ignite {_t} for 1 second
    wait 1 second

function monk_frost_bonus(p: player, t: entity, bonus: number):
  if "%{_t}%" contains "molhado":
    damage {_t} by damage of {_p} * bonus parsed as number

function monk_vortex_step(p: player, distance: number, seconds: number, damage: number):
  push {_p} forward distance parsed as number
  repeat seconds parsed as number times:
    loop all entities in radius 2 around {_p}:
      if loop-entity is not {_p}:
        damage loop-entity by damage parsed as number
    wait 1 second

function monk_stone_skin(p: player, seconds: number, amount: number):
  apply resistance 1 to {_p} for seconds parsed as number seconds
  execute console command "raceseffects apply_resistance_exhaust %{_p}%"

function monk_four_storm(p: player, radius: number, seconds: number, damage: number):
  repeat floor(seconds parsed as number / 2) times:
    loop all entities in radius radius parsed as number around {_p}:
      if loop-entity is not {_p}:
        damage loop-entity by damage parsed as number
        pull loop-entity towards {_p} by 0.2
    show dragon breath for all players at location of {_p} with radius radius parsed as number
    wait 2 seconds
